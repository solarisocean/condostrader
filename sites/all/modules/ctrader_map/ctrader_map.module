<?php


/**
 * Implements hook_menu().
 */
function ctrader_map_menu() {
  $items = array();
  $items['create-terms'] = array(
    'title' => 'Create Toronto region terms',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_ctrader_map_region_taxonomy_form'),
    'access arguments' => array('administer modules'),
  );
  return $items;
}


/**
 * Implements hook_init().
 */
function ctrader_map_init() {
  drupal_add_css(drupal_get_path('module', 'ctrader_map') . '/css/ctrader-map.css');
//  unset($_SESSION['neighbourhood_json']);
}


/**
 * Implements hook_search_api_solr_query_alter().
 */
function ctrader_map_search_api_solr_query_alter(array &$call_args, SearchApiQueryInterface $query) {
  switch ($query->getOption('search id')) {
    case 'search_api_views:condo_search_page:page':
    case 'search_api_views:condo_search_page:block_1':
    case 'search_api_views:search_results_ctrader:block_1':
    case 'search_api_views:search_results_ctrader:page_1':
      $query_string = serialize($query);
      $_SESSION['query_from_view'] = $query_string;
      break;
    case 'search_api_views:map:page':
      break;
  }
  $options = $query->getOptions();
  if (isset($options['query_label'])) {
    switch ($options['query_label']) {
      case 'search_on_map':
        $need_this_fields = array(
          'item_id',
          'score',
          'ss_field_addr__torcond',
          'tm_label',
          'locs_field_test_geofilld$latlon',
          'fs_field_lp_dol__torcond',
          'ss_field_community__torcond',
          'ss_field_community_code__torcond',
          'ss_field_community__torcond',
          'tm_field_ml_num__torcond',
          'ss_field_ml_num__torcond',
        );
        $call_args['params']['fl'] = implode(',', $need_this_fields);
        break;
    }
  }
}


/**
 * Implements hook_block_info().
 */
function ctrader_map_block_info() {
  $blocks = array();
  $blocks['main_map'] = array(
    'info' => t('Custom block: Main Map'),
//    'cache' => DRUPAL_NO_CACHE,
  );
  return $blocks;
}


/**
 * Implements hook_block_view().
 */
function ctrader_map_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'main_map':
      $server = search_api_server_load('solr_server');

      if (isset($_SESSION['query_from_view'])) {
        $query = unserialize($_SESSION['query_from_view']);
        $query->setOption('limit', NULL);
        $query->setOption('query_label', 'search_on_map');
        $query->fields(array());
//    unset($_SESSION['query_from_view']);
      }
      else {
        $index = search_api_index_load('toronto_condo_index');
        $query = new SearchApiQuery($index);
        $query->keys();
        $query->fields(array());
//    $query->range(0, 150);
      }

      $solr = new SearchApiSolrService($server);
      $result = $solr->search($query);

      $condos_neighbourhood_names = array();
      $array_json = array();
      foreach ($result['results'] as $key => $item) {
        if (!empty($item['fields']['field_test_geofilld:latlon'])) {
          $coord = explode(',', $item['fields']['field_test_geofilld:latlon']);
        }
        else {
          // Toronto City default coordinates.
          $coord = array(
            '43.760' . rand(0, 9),
            '-79.390' . rand(0, 9),
          );
        }
        $popup_content = '';
        $mls_num = isset($item['fields']['field_ml_num__torcond'][0]) ? '<br>MLS #: ' . $item['fields']['field_ml_num__torcond'][0] : '';
        $popup_content .= 'id: ' . $item['fields']['search_api_id'] . $mls_num;
        if (!empty($item['fields']['field_addr__torcond'][0])) {
          $popup_content .= '<br>' . $item['fields']['field_addr__torcond'][0];
        }
        if (!empty($item['fields']['field_lp_dol__torcond'])) {
          $popup_content .= '<br>$' . $item['fields']['field_lp_dol__torcond'];
        }
        if (!empty($item['fields']['field_community__torcond'][0])) {
          $popup_content .= '<br>' . $item['fields']['field_community__torcond'][0];
        }

        $prepared = array(
          'id' => $item['id'],
          'type' => 'Feature',
          'properties' => array(
            'name' => !empty($item['fields']['field_addr__torcond'][0]) ? $item['fields']['field_addr__torcond'][0] : 'Condo',
            'popupContent' => $popup_content,
          ),
          'geometry' => array(
            'type' => 'Point',
            'coordinates' => is_array($coord) ? array(
              (float) $coord[1],
              (float) $coord[0]
            ) : '',
          ),
        );
        $array_json[] = $prepared;

        if (!empty($item['fields']['field_community__torcond'][0]) && !in_array($item['fields']['field_community__torcond'][0], $condos_neighbourhood_names)) {
          $condos_neighbourhood_names[] = $item['fields']['field_community__torcond'][0];
        }
        sort($condos_neighbourhood_names);
      }
      drupal_add_js(array('condosMapData' => $array_json), 'setting');
      _ctrader_map_prepare_neighbourhoods_json($condos_neighbourhood_names, $array_json);

      $path = libraries_get_path('leaflet');
      drupal_add_js($path . '/leaflet-src.js');
      drupal_add_css($path . '/leaflet.css');

      $path = libraries_get_path('leaflet_label');
      drupal_add_js($path . '/dist/leaflet.label.js');
      drupal_add_css($path . '/dist/leaflet.label.css');

      $path = libraries_get_path('Leaflet.draw');
      drupal_add_js($path . '/dist/leaflet.draw.js');
      drupal_add_css($path . '/dist/leaflet.draw.css');

      //Leaflet Free Draw tool.
      $path = libraries_get_path('leafletFreeDraw');
      drupal_add_js($path . '/d3.min.js');
      drupal_add_js($path . '/clipper.js');
      drupal_add_js($path . '/concavehull.min.js');
      drupal_add_js($path . '/FreeDraw.js');
      drupal_add_js($path . '/Options.js');
      drupal_add_js($path . '/Utilities.js');
      drupal_add_js($path . '/Memory.js');
      drupal_add_js($path . '/Hull.js');

      $path = libraries_get_path('leaflet_markercluster');
      drupal_add_css($path . '/dist//dist/MarkerCluster.css');
      drupal_add_css($path . '/dist/MarkerCluster.Default.css');
      drupal_add_js($path . '/dist/leaflet.markercluster.js');

      drupal_add_js(drupal_get_path('module', 'ctrader_map') . '/js/custom_map.js');

      // Sends data to js if it is polygon search.
      if (isset($_GET['polygon'])) {
        $pre_coordinates = explode(',', $_GET['polygon']);
        $coordinates = array();
        foreach ($pre_coordinates as $value) {
          $coordinates[] = explode(' ', $value);
        }
        $user_polygon_search = array(
          'geometry' => array(
            'coordinates' => array(
              $coordinates,
            ),
            'type' => 'Polygon'
          ),
          'properties' => array(
            'name' => 'User search polygon',
          ),
          'type' => 'Feature',
        );
        drupal_add_js(array('userPolygonSearch' => $user_polygon_search), 'setting');
      }

      $block['subject'] = 'Block with main map';
      $block['content'] = '<div id="mapid"></div>';
      break;
  }
  return $block;
}


/**
 * Implements hook_entity_presave().
 */
function ctrader_map_entity_presave($entity, $type) {
  switch ($type) {
    case DREALTY_ENTITY_TYPE:
      if (!isset($entity->field_city_region__torcond[LANGUAGE_NONE][0]['tid'])) {
        if (!isset($_SESSION['neighbourhoods_terms_polygons_data'])) {
          $vid = taxonomy_vocabulary_machine_name_load('neighbourhoods'); //Neighbourhoods vocabulary.
          $vid = $vid->vid;
          $vocabulary_term_entities = taxonomy_get_tree($vid, 0, 3, TRUE);
          $terms_polygon = array();
          foreach ($vocabulary_term_entities as $tax_term) {
            $tax_term_id = $tax_term->tid;
            $polygon = isset($tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom']) ? $tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom'] : NULL;
            if ($polygon !== NULL && $polygon != 'GEOMETRYCOLLECTION EMPTY') {
              if (strrpos($tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom'], 'MULTIPOLYGON') === FALSE) {
                $polygon = $tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom'];
                $polygon = str_replace(array(
                  'POLYGON ',
                  '(',
                  ')'
                ), '', $polygon);
                $polygon = explode(', ', $polygon);
              }
            }
            $terms_polygon[$tax_term_id] = $polygon;

            $polygon = NULL;
            $tax_term_id = NULL;
          }
          $_SESSION['neighbourhoods_terms_polygons_data'] = $terms_polygon;
        }

        $terms_polygon = $_SESSION['neighbourhoods_terms_polygons_data'];
        require_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'ctrader_map') . '/classes/pointLocation.php';
        $pointLocation = new pointLocation();
        $point = $entity->field_test_geofilld[LANGUAGE_NONE][0]['lon'] . ' ' . $entity->field_test_geofilld[LANGUAGE_NONE][0]['lat'];
        foreach ($terms_polygon as $term_id => $term_polygon) {
          if (is_array($term_polygon)) {
            $check = $pointLocation->pointInPolygon($point, $term_polygon);
            if ($check == 'inside') {
              $entity->field_city_region__torcond[LANGUAGE_NONE][0]['tid'] = $term_id;
            }
          }
        }
      }
      break;
  }
}


/**
 * Implements hook_ctools_plugin_directory().
 */
function ctrader_map_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'ctools' && !empty($plugin_type)) {
    return "plugins/{$plugin_type}";
  }
}


/**
 * Implements hook_theme().
 */
function ctrader_map_theme($existing, $type, $theme, $path) {
  $themes = array();
  $themes['ctrader_single_condo_map_legend'] = array(
    'variables' => array(
      'neighbourhood_name' => 'Ontario',
      'neighbourhood_link' => NULL,
      'city_name' => NULL,
      'city_link' => NULL,
      'address' => NULL,
      'country_region' => NULL,
      'zip_code' => NULL,
      'unit' => NULL,
      'community_name' => NULL,
      'community_link' => NULL,
      'area_name' => NULL,
      'area_link' => NULL,
    ),
    'template' => 'theme/single-condo-map-legend',
  );
  return $themes;
}


/**
 * Creates json with Toronto neighbourhoods coordinates.
 */
function _ctrader_map_prepare_neighbourhoods_json($condos_neighbourhood_names = array(), $points_array = array()) {
  if (!isset($_SESSION['neighbourhood_json'])) {
    $vid = taxonomy_vocabulary_machine_name_load('neighbourhoods'); //Neighbourhoods vocabulary.
    $vid = $vid->vid;
    $vocabulary_term_entities = taxonomy_get_tree($vid, 0, 3, TRUE);
    $terms_polygon_prejson = array();
    foreach ($vocabulary_term_entities as $tax_term) {
      $polygon = isset($tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom']) ? $tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom'] : NULL;
      if ($polygon !== NULL && $polygon != 'GEOMETRYCOLLECTION EMPTY') {
        $tax_term_id = $tax_term->tid;
        $tax_term_name = $tax_term->name;
        $polygon_popup_content = $tax_term_name;
        $coordinates = array();
        if (strrpos($tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom'], 'MULTIPOLYGON') === FALSE) {
          $type = 'Polygon';
          $polygon = str_replace(array('POLYGON ', '(', ')'), '', $polygon);
          $polygon = explode(', ', $polygon);
          $pre_coordinates = array();
          foreach ($polygon as $value) {
            $pre_coordinates[] = explode(' ', $value);
          }
          $coordinates[] = $pre_coordinates;
        }
        else {
          $type = 'MultiPolygon';
          $pre_coordinates = array();
          $polygon = str_replace(array(
            'MULTIPOLYGON ',
            '(((',
            ')))'
          ), '', $polygon);
          $pre_multi = explode('), (', $polygon);
          $pre_multi_coordinates = array();
          foreach ($pre_multi as $value) {
            $pre_points = explode(',', $value);
            $points = array();
            foreach ($pre_points as $pre_point) {
              $pre_point = trim($pre_point);
              $points[] = explode(' ', $pre_point);
            }
            $pre_multi_coordinates[] = $points;
          }
          $coordinates[] = $pre_multi_coordinates;
        }
        $terms_polygon_prejson[] = array(
          'geometry' => array(
            'coordinates' => $coordinates,
            'type' => $type,
          ),
          'properties' => array(
            'name' => $tax_term_name,
            'popupContent' => $polygon_popup_content,
          ),
          'id' => $tax_term_id,
          'type' => 'Feature',
        );
      }
    }
    $_SESSION['neighbourhood_json'] = $terms_polygon_prejson;
  }
  drupal_add_js(array('neighbourhoodsMapData' => $_SESSION['neighbourhood_json']), 'setting');

  return $_SESSION['neighbourhood_json'];
}

function _ctrader_map_kml_to_xml() {
  $xml = simplexml_load_file(drupal_get_path('module', 'ctrader_map') . '/inc/toronto_neighbourhoods.kml');
  $communities_array = array();
  $converted_kml_to_xml_string = '';
  foreach ($xml->Document->Folder->Placemark as $item) {
    $communities_array[] = (array) $item;
  }
  foreach ($communities_array as $item) {
    $coord_array = explode(';', $item['Polygon']->outerBoundaryIs->LinearRing->coordinates);
    $coord_xml = '<json_polygon>';
    foreach ($coord_array as $value) {
      $coord_pair = explode(',', $value);
      $coord_pair_string = '<element>' . trim($coord_pair[1]) . ',' . trim($coord_pair[0]) . '</element>';
      $coord_xml .= $coord_pair_string;
    }
    $coord_xml .= '</json_polygon>';
    $xml_string_item = '<element>' . $coord_xml . '<name>' . $item['name'] . '</name></element>';
    $converted_kml_to_xml_string .= $xml_string_item;
  }
  return $converted_kml_to_xml_string;
}


/**
 * Provides button for creating taxonomy tree in Neighbourhoods vocabulary.
 */
function _ctrader_map_region_taxonomy_form($form, &$form_state) {
  $form = array();
  $form['vocab_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Vocabulary machine name'),
    '#default_value' => 'neighbourhoods',
    '#size' => 42,
    '#maxlength' => 42,
    '#required' => TRUE,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Start terms creating'),
//    '#disabled' => TRUE,
  );
  return $form;
}

/**
 * _ctrader_map_region_taxonomy_form submit function.
 */
function _ctrader_map_region_taxonomy_form_submit($form, &$form_state) {
  unset($_SESSION['neighbourhood_json']);
  _ctrader_map_taxonomy_create($form_state['values']['vocab_name']);
}


/**
 * Creates taxonomy term for each Toronto region.
 */
function _ctrader_map_taxonomy_create($vocab_machine_name) {
  $vid = taxonomy_vocabulary_machine_name_load($vocab_machine_name); //Neighbourhoods vocabulary.
  if ($vid == FALSE) {
    drupal_set_message(t('Vocabulary does not exist.'), 'error');
    return;
  }
  else {
    $vid = $vid->vid;
  }

  // Checks if vocabulary is empty.
  $check_vocab = taxonomy_get_tree($vid, 0, 1);
  if (!empty($check_vocab)) {
    drupal_set_message(t('Vocabulary is not empty.'), 'warning');
    drupal_set_message(t('You should clear Neighbourhoods vocabulary before creating new taxonomy tree.'), 'warning');
    return;
  }

  $condos_ca = simplexml_load_file(drupal_get_path('module', 'ctrader_map') . '/inc/condos-ca-01-06-16.xml');
  $elements = reset($condos_ca->tax);

  $grand_parent_ids = array();
  $parent_ids = array();
  foreach ($elements as $element) {
    if ($element->parent_id->__toString() == 0) {
      $grand_parent_ids[] = $element->id->__toString();
    }
  }
  foreach ($elements as $element) {
    if ($element->grandparent_id->__toString() !== 0 && in_array($element->parent_id->__toString(), $grand_parent_ids)) {
      $parent_ids[] = $element->id->__toString();
    }
  }

  // Creates first level terms.
  $tree = taxonomy_get_tree($vid, 0, NULL, TRUE);
  foreach ($elements as $key => $element) {
    if (in_array($element->id->__toString(), $grand_parent_ids)) {
      _prepare_taxonomy_term($element, $vid, $tree);
      unset($elements[$key]);
    }
  }

  // Creates second level terms.
  $tree = taxonomy_get_tree($vid, 0, NULL, TRUE);
  foreach ($elements as $key => $element) {
    if (in_array($element->id->__toString(), $parent_ids)) {
      _prepare_taxonomy_term($element, $vid, $tree);
      unset($elements[$key]);
    }
  }

  // Creates third level terms.
  $tree = taxonomy_get_tree($vid, 0, NULL, TRUE);
  foreach ($elements as $key => $element) {
    _prepare_taxonomy_term($element, $vid, $tree);
    unset($elements[$key]);
  }

  /**
   * $vid = taxonomy_vocabulary_machine_name_load('neighbourhoods'); //Neighbourhoods vocabulary.
   * $vid = $vid->vid;
   *
   * $select_list_condos_ca = array(
   * '1' => array(
   * 'Toronto' => array(
   * '590' => 'Downtown',
   * '597' => 'Midtown',
   * '593' => 'North York',
   * '596' => 'East End',
   * '598' => 'East York',
   * '595' => 'West End',
   * '594' => 'York Crosstown',
   * '592' => 'Etobicoke',
   * '591' => 'Scarborough',
   * )
   * ),
   * '2' => array(
   * 'Peel' => array(
   * '43' => 'Brampton',
   * '44' => 'Mississauga',
   * )
   * ),
   * '4' => array(
   * 'York Region' => array(
   * '54' => 'Aurora',
   * '49' => 'King',
   * '51' => 'Markham',
   * '55' => 'Newmarket',
   * '52' => 'Richmond Hill',
   * '50' => 'Vaughan',
   * )
   * ),
   * '3' => array(
   * 'Halton' => array(
   * '45' => 'Milton',
   * '46' => 'Burlington',
   * '47' => 'Halton Hills',
   * '48' => 'Oakville',
   * )
   * ),
   * '0' => array(
   * 'grandparent_0' => array(
   * '599' => 'Hamilton',
   * ),
   * ),
   * '5' => array(
   * 'grandparent_5' => array(
   * '59' => 'parent_59',
   * '60' => 'parent_60',
   * '61' => 'parent_61',
   * '62' => 'parent_62',
   * '63' => 'parent_63',
   * '64' => 'parent_64',
   * '65' => 'parent_65',
   * '66' => 'parent_66',
   * '67' => 'parent_67',
   * ),
   * ),
   * );
   *
   * // Creates main items for vocabulary.
   * foreach ($select_list_condos_ca as $grand_id => $grand_parent) {
   * $grand_pa_name = array_keys($grand_parent);
   * $grand_pa_name = array_shift($grand_pa_name);
   * $grand_pa = new stdClass();
   * $grand_pa->name = $grand_pa_name;
   * $grand_pa->vid = $vid;
   * $grand_pa->field_id[LANGUAGE_NONE][0]['value'] = $grand_id;
   * taxonomy_term_save($grand_pa);
   * $grand_parent_just_created = taxonomy_get_term_by_name($grand_pa_name);
   * $grand_parent_just_created = reset($grand_parent_just_created);
   * $grand_parent_id = $grand_parent_just_created->tid;
   * foreach ($grand_parent[$grand_pa_name] as $child_term_id => $child_term_name) {
   * $child_term = new stdClass();
   * $child_term->name = $child_term_name;
   * $child_term->vid = $vid;
   * $child_term->field_id[LANGUAGE_NONE][0]['value'] = $child_term_id;
   * $child_term->parent = array($grand_parent_id => $grand_parent_id);
   * taxonomy_term_save($child_term);
   * }
   * }
   *
   * $xml = simplexml_load_file(drupal_get_path('module', 'ctrader_map') . '/inc/condos-ca.xml');
   * $vocabulary_main_terms = taxonomy_get_tree($vid, 0, 2, TRUE);
   * foreach ($xml as $element) {
   * $term_name = $element->name->__toString();
   * $term_field_id_value = $element->id->__toString();
   * $xml_parent_id = $element->parent_id->__toString();
   *
   * //Creates json for geofield.
   * $is_polygon = TRUE;
   * $coordinates = array();
   * foreach ($element->json_polygon->element as $pair) {
   * $count_pair = count($pair);
   * if (!$count_pair) {
   * $point = explode(',', $pair);
   * $point = array_reverse($point);
   * $coordinates[] = $point;
   * }
   * // if multipolygon
   * else {
   * $is_polygon = FALSE;
   * $pre_coordinates = array();
   * foreach ((array) $pair->element as $value) {
   * $point = explode(',', $value);
   * $point = array_reverse($point);
   * $pre_coordinates[] = $point;
   * }
   * $coordinates[] = $pre_coordinates;
   * }
   * }
   * if ($is_polygon == TRUE && implode('_', $coordinates[0]) != implode('_', end($coordinates))) {
   * $coordinates[] = $coordinates[0];
   * }
   * $prepared = array(
   * 'id' => $element->id->__toString(),
   * 'type' => 'Feature',
   * 'properties' => array(
   * 'name' => !empty($element->name) ? $element->name->__toString() : 'Neighbourhood',
   * ),
   * 'geometry' => array(
   * 'type' => $is_polygon ? 'Polygon' : 'MultiPolygon',
   * 'coordinates' => array(
   * $coordinates,
   * ),
   * ),
   * );
   * $polygon_json = json_encode($prepared);
   *
   * // Finds which one of existed terms would be parent
   * // and create new parent term if not exist.
   * $parent_id = -1;
   * foreach ($vocabulary_main_terms as $parent_terms) {
   * if ($xml_parent_id == $parent_terms->field_id[LANGUAGE_NONE][0]['value']) {
   * $parent_id = $parent_terms->tid;
   * }
   * }
   * if ($parent_id == -1) {
   * $parent_term = new stdClass();
   * $parent_term->name = 'parent_' . $element->parent_id->__toString();
   * $parent_term->vid = $vid;
   * $parent_term->field_id[LANGUAGE_NONE][0]['value'] = $element->parent_id->__toString();
   * $parent_term->parent = array($element->grandparent_id->__toString() => $element->grandparent_id->__toString());
   * taxonomy_term_save($parent_term);
   * $parent_just_created = taxonomy_get_term_by_name('parent_' . $element->parent_id->__toString());
   * $parent_just_created = reset($parent_just_created);
   * $parent_id = $parent_just_created->tid;
   * $vocabulary_main_terms = taxonomy_get_tree($vid, 0, 2, TRUE);
   * }
   *
   * $term = new stdClass();
   * $term->name = $term_name;
   * $term->vid = $vid;
   * $term->field_community_geolocation[LANGUAGE_NONE][0]['geom'] = $polygon_json;
   * $term->field_community_geolocation[LANGUAGE_NONE][0]['input_format'] = 'json';
   * $term->field_id[LANGUAGE_NONE][0]['value'] = $term_field_id_value;
   * $term->parent = array($parent_id => $parent_id);
   * taxonomy_term_save($term);
   * }
   */
}


/**
 * Prepares term object and saves taxonomy term.
 *
 * @param $element - item from xml file.
 * @param $vid - Neighbourhoods vocabulary id.
 * @param $tree - tree of existed Neighbourhoods vocabulary taxonomy terms.
 */
function _prepare_taxonomy_term($element, $vid, $tree) {
  $term = new stdClass();
  $term->name = $element->name->__toString();
  $term->vid = $vid;
  $term->field_id[LANGUAGE_NONE][0]['value'] = $element->id->__toString();

  //Creates json for geofield.
  $is_polygon = TRUE;
  $coordinates = array();
  foreach ($element->json_polygon->element as $pair) {
    $count_pair = count($pair);
    if (!$count_pair) {
      $point = explode(',', $pair);
      $point = array_reverse($point);
      $coordinates[] = $point;
    }
    // if multipolygon
    else {
      $is_polygon = FALSE;
      $pre_coordinates = array();
      foreach ((array) $pair->element as $value) {
        $point = explode(',', $value);
        $point = array_reverse($point);
        $pre_coordinates[] = $point;
      }
      $coordinates[] = $pre_coordinates;
    }
  }
  if ($is_polygon == TRUE && implode('_', $coordinates[0]) != implode('_', end($coordinates))) {
    $coordinates[] = $coordinates[0];
  }
  $prepared = array(
    'id' => $element->id->__toString(),
    'type' => 'Feature',
    'properties' => array(
      'name' => !empty($element->name) ? $element->name->__toString() : 'Neighbourhood',
    ),
    'geometry' => array(
      'type' => $is_polygon ? 'Polygon' : 'MultiPolygon',
      'coordinates' => array(
        $coordinates,
      ),
    ),
  );
  $polygon_json = json_encode($prepared);
  $term->field_community_geolocation[LANGUAGE_NONE][0]['geom'] = $polygon_json;
  $term->field_community_geolocation[LANGUAGE_NONE][0]['input_format'] = 'json';

  // Added parents if exists.
  foreach ($tree as $value) {
    if (isset($value->field_id[LANGUAGE_NONE][0]['value']) && $value->field_id[LANGUAGE_NONE][0]['value'] == $element->parent_id->__toString()) {
      if (!empty($value->parents)) {
        $term->parent = $value->parents;
        $term->parent[$value->tid] = $value->tid;
        unset($term->parent[0]);
      }
      else {
        $term->parent[$value->tid] = $value->tid;
      }
    }
  }
  taxonomy_term_save($term);
}
