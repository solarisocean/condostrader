<?php


/**
 * Implements hook_menu().
 */
function ctrader_map_menu() {
  $items = array();
  $items['create-terms'] = array(
    'title' => 'Create Toronto region terms',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_ctrader_map_region_taxonomy_form'),
    'access arguments' => array('administer modules'),
  );
  return $items;
}


/**
 * Implements hook_init().
 */
function ctrader_map_init() {
  $t_n_list = array(
    0 => 'Agincourt North',
    1 => 'Agincourt South-Malvern West',
    2 => 'Alderwood',
    3 => 'Annex',
    4 => 'Banbury-Don Mills',
    5 => 'Bathurst Manor',
    6 => 'Bay Street Corridor',
    7 => 'Bayview Village',
    8 => 'Bayview Woods-Steeles',
    9 => 'Bedford Park-Nortown',
    10 => 'Beechborough-Greenbrook',
    11 => 'Bendale',
    12 => 'Birchcliffe-Cliffside',
    13 => 'Black Creek',
    14 => 'Blake-Jones',
    15 => 'Briar Hill-Belgravia',
    16 => 'Bridle Path-Sunnybrook-York Mills',
    17 => 'Broadview North',
    18 => 'Brookhaven-Amesbury',
    19 => 'Cabbagetown-South St. James Town',
    20 => 'Caledonia-Fairbank',
    21 => 'Casa Loma',
    22 => 'Centennial Scarborough',
    23 => 'Church-Yonge Corridor',
    24 => 'Clairlea-Birchmount',
    25 => 'Clanton Park',
    26 => 'Cliffcrest',
    27 => 'Corso Italia-Davenport',
    28 => 'Crescent Town',
    29 => 'Danforth',
    30 => 'Danforth Village-East York',
    31 => 'Don Valley Village',
    32 => 'Dorset Park',
    33 => 'Dovercourt-Wallace Emerson-Junction',
    34 => 'Downsview-Roding-CFB',
    35 => 'Dufferin Grove',
    36 => 'East End-Danforth',
    37 => 'East York',
    38 => 'Edenbridge-Humber Valley',
    39 => 'Eglinton East',
    40 => 'Elms-Old Rexdale',
    41 => 'Englemount-Lawrence',
    42 => 'Eringate-Centennial-West Deane',
    43 => 'Etobicoke West Mall',
    44 => 'Flemingdon Park',
    45 => 'Forest Hill North',
    46 => 'Forest Hill South',
    47 => 'Glenfield-Jane Heights',
    48 => 'Greenwood-Coxwell',
    49 => 'Guildwood',
    50 => 'Henry Farm',
    51 => 'High Park North',
    52 => 'High Park-Swansea',
    53 => 'Highland Creek',
    54 => 'Hillcrest Village',
    55 => 'Humber Heights',
    56 => 'Humber Summit',
    57 => 'Humberlea-Pelmo Park W4',
    58 => 'Humberlea-Pelmo Park W5',
    59 => 'Humbermede',
    60 => 'Humewood-Cedarvale',
    61 => 'Ionview',
    62 => 'Islington-City Centre West',
    63 => 'Junction Area',
    64 => 'Keelesdale-Eglinton West',
    65 => 'Kennedy Park',
    66 => 'Kensington-Chinatown',
    67 => 'Kingsview Village-The Westway',
    68 => 'Kingsway South',
    69 => 'L\'Amoreaux',
    70 => 'Lambton Baby Point',
    71 => 'Lansing-Westgate',
    72 => 'Lawrence Park North',
    73 => 'Lawrence Park South',
    74 => 'Leaside',
    75 => 'Little Portugal',
    76 => 'Long Branch',
    77 => 'Malvern',
    78 => 'Maple Leaf',
    79 => 'Markland Wood',
    80 => 'Milliken',
    81 => 'Mimico',
    82 => 'Morningside',
    83 => 'Moss Park',
    84 => 'Mount Dennis',
    85 => 'Mount Olive-Silverstone-Jamestown',
    86 => 'Mount Pleasant East',
    87 => 'Mount Pleasant West',
    88 => 'New Toronto',
    89 => 'Newtonbrook East',
    90 => 'Newtonbrook West',
    91 => 'Niagara',
    92 => 'North Riverdale',
    93 => 'North St. James Town',
    94 => 'O\'Connor-Parkview',
    95 => 'Oakridge',
    96 => 'Oakwood-Vaughan',
    97 => 'Palmerston-Little Italy',
    98 => 'Parkwoods-Donalda',
    99 => 'Pleasant View',
    100 => 'Princess-Rosethorn',
    101 => 'Regent Park',
    102 => 'Rexdale-Kipling',
    103 => 'Rockcliffe-Smythe',
    104 => 'Roncesvalles',
    105 => 'Rosedale-Moore Park',
    106 => 'Rouge E10',
    107 => 'Rouge E11',
    108 => 'Runnymede-Bloor West Village',
    109 => 'Rustic',
    110 => 'Scarborough Village',
    111 => 'South Parkdale',
    112 => 'South Riverdale',
    113 => 'St. Andrew-Windfields',
    114 => 'Steeles',
    115 => 'Stonegate-Queensway',
    116 => 'Tam O\'Shanter-Sullivan',
    117 => 'The Beaches',
    118 => 'Thorncliffe Park',
    119 => 'Trinity-Bellwoods',
    120 => 'University',
    121 => 'Victoria Village',
    122 => 'Waterfront Communities C1',
    123 => 'Waterfront Communities C8',
    124 => 'West Hill',
    125 => 'West Humber-Clairville',
    126 => 'Westminster-Branson',
    127 => 'Weston',
    128 => 'Weston-Pellam Park',
    129 => 'Wexford-Maryvale',
    130 => 'Willowdale East',
    131 => 'Willowdale West',
    132 => 'Willowridge-Martingrove-Richview',
    133 => 'Woburn',
    134 => 'Woodbine Corridor',
    135 => 'Woodbine-Lumsden',
    136 => 'Wychwood',
    137 => 'Yonge-Eglinton',
    138 => 'Yonge-St. Clair',
    139 => 'York University Heights',
    140 => 'Yorkdale-Glen Park',
  );
//  $kml_to_xml = _ctrader_map_kml_to_xml();
}


/**
 * Implements hook_search_api_solr_query_alter().
 */
function ctrader_map_search_api_solr_query_alter(array &$call_args, SearchApiQueryInterface $query) {
  switch ($query->getOption('search id')) {
    case 'search_api_views:condo_search_page:page':
    case 'search_api_views:condo_search_page:block_1':
      $query_string = serialize($query);
      $_SESSION['query_from_view'] = $query_string;
      break;
    case 'search_api_views:map:page':
      break;
  }
  $options = $query->getOptions();
  if (isset($options['query_label'])) {
    switch ($options['query_label']) {
      case 'search_on_map':
        $need_this_fields = array(
          'item_id',
          'score',
          'tm_field_addr__torcond',
          'tm_label',
          'locs_field_test_geofilld$latlon',
          'fs_field_lp_dol__torcond',
          'tm_field_community__torcond',
          'tm_field_community_code__torcond',
          'tm_field_community__torcond',
          'tm_field_ml_num__torcond',
        );
        $call_args['params']['fl'] = implode(',', $need_this_fields);
        break;
    }
  }
}


/**
 * Implements hook_block_info().
 */
function ctrader_map_block_info() {
  $blocks = array();
  $blocks['main_map'] = array(
    'info' => t('Custom block: Main Map'),
//    'cache' => DRUPAL_NO_CACHE,
  );
  return $blocks;
}


/**
 * Implements hook_block_view().
 */
function ctrader_map_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'main_map':
      $server = search_api_server_load('solr_server');

      if (isset($_SESSION['query_from_view'])) {
        $query = unserialize($_SESSION['query_from_view']);
        $query->setOption('limit', NULL);
        $query->setOption('query_label', 'search_on_map');
        $query->fields(array());
//    unset($_SESSION['query_from_view']);
      }
      else {
        $index = search_api_index_load('toronto_condo_index');
        $query = new SearchApiQuery($index);
        $query->keys();
        $query->fields(array());
//    $query->range(0, 150);
      }

      $solr = new SearchApiSolrService($server);
      $result = $solr->search($query);

      $condos_neighbourhood_names = array();
      $array_json = array();
      foreach ($result['results'] as $key => $item) {
        if (!empty($item['fields']['field_test_geofilld:latlon'])) {
          $coord = explode(',', $item['fields']['field_test_geofilld:latlon']);
        }
        else {
          // Toronto City default coordinates.
          $coord = array(
            '43.76',
            '-79.39'
          );
        }
        $popup_content = '';
        $popup_content .= 'id: ' . $item['fields']['search_api_id'] . '<br>MLS #: ' . $item['fields']['field_ml_num__torcond'][0];
        if (!empty($item['fields']['field_addr__torcond'][0])) {
          $popup_content .= '<br>' . $item['fields']['field_addr__torcond'][0];
        }
        if (!empty($item['fields']['field_lp_dol__torcond'])) {
          $popup_content .= '<br>$' . $item['fields']['field_lp_dol__torcond'];
        }
        if (!empty($item['fields']['field_community__torcond'][0])) {
          $popup_content .= '<br>' . $item['fields']['field_community__torcond'][0];
        }

        $prepared = array(
          'id' => $item['id'],
          'type' => 'Feature',
          'properties' => array(
            'name' => !empty($item['fields']['field_addr__torcond'][0]) ? $item['fields']['field_addr__torcond'][0] : 'Condo',
            'popupContent' => $popup_content,
          ),
          'geometry' => array(
            'type' => 'Point',
            'coordinates' => is_array($coord) ? array(
              (float) $coord[1],
              (float) $coord[0]
            ) : '',
          ),
        );
        $array_json[] = $prepared;

        if (!empty($item['fields']['field_community__torcond'][0]) && !in_array($item['fields']['field_community__torcond'][0], $condos_neighbourhood_names)) {
          $condos_neighbourhood_names[] = $item['fields']['field_community__torcond'][0];
        }
        sort($condos_neighbourhood_names);
      }
      drupal_add_js(array('condosMapData' => $array_json), 'setting');
      _ctrader_map_prepare_neighbourhoods_json($condos_neighbourhood_names, $array_json);

      $path = libraries_get_path('leaflet');
      drupal_add_js($path . '/leaflet-src.js');
      drupal_add_css($path . '/leaflet.css');

      $path = libraries_get_path('Leaflet.draw');
      drupal_add_js($path . '/dist/leaflet.draw.js');
      drupal_add_css($path . '/dist/leaflet.draw.css');


      // another draw tools.
//  $path = libraries_get_path('ConcaveHull');
//  drupal_add_js($path . '/dist/concavehull.js');
//  $path = libraries_get_path('d3');
//  drupal_add_js($path . '/d3.js');
//  $path = libraries_get_path('JsClipper');
//  drupal_add_js($path . '/clipper.js');
//  $path = libraries_get_path('Leaflet.FreeDraw');
//  drupal_add_js($path . '/dist/leaflet.freedraw-src.js');
//  $path = drupal_get_path('module', 'ctrader_map');
//  drupal_add_js($path . '/js/neighbourhood-json.js');


      $path = libraries_get_path('leaflet_markercluster');
      drupal_add_css($path . '/dist//dist/MarkerCluster.css');
      drupal_add_css($path . '/dist/MarkerCluster.Default.css');
      drupal_add_js($path . '/dist/leaflet.markercluster.js');

      drupal_add_js(drupal_get_path('module', 'ctrader_map') . '/js/custom_map.js');

      $block['subject'] = 'Block with main map';
      $block['content'] = '<div id="mapid" style="height:750px;"></div>';
      break;
  }
  return $block;
}


/**
 * Implements hook_entity_presave().
 */
function ctrader_map_entity_presave($entity, $type) {
  switch ($type) {
    case DREALTY_ENTITY_TYPE:
      if (!isset($entity->field_city_region__torcond[LANGUAGE_NONE][0]['tid'])) {
        if (!isset($_SESSION['neighbourhoods_terms_polygons_data'])) {
          $vid = taxonomy_vocabulary_machine_name_load('neighbourhoods'); //Neighbourhoods vocabulary.
          $vid = $vid->vid;
          $vocabulary_term_entities = taxonomy_get_tree($vid, 0, 3, TRUE);
          $terms_polygon = array();
          foreach ($vocabulary_term_entities as $tax_term) {
            $tax_term_id = $tax_term->tid;
            $polygon = isset($tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom']) ? $tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom'] : NULL;
            if ($polygon !== NULL && $polygon != 'GEOMETRYCOLLECTION EMPTY') {
              if (strrpos($tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom'], 'MULTIPOLYGON') === FALSE) {
                $polygon = $tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom'];
                $polygon = str_replace(array(
                  'POLYGON ',
                  '(',
                  ')'
                ), '', $polygon);
                $polygon = explode(', ', $polygon);
              }
            }
            $terms_polygon[$tax_term_id] = $polygon;

            $polygon = NULL;
            $tax_term_id = NULL;
          }
          $_SESSION['neighbourhoods_terms_polygons_data'] = $terms_polygon;
        }

        $terms_polygon = $_SESSION['neighbourhoods_terms_polygons_data'];
        require_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'ctrader_map') . '/classes/pointLocation.php';
        $pointLocation = new pointLocation();
        $point = $entity->field_test_geofilld[LANGUAGE_NONE][0]['lon'] . ' ' . $entity->field_test_geofilld[LANGUAGE_NONE][0]['lat'];
        foreach ($terms_polygon as $term_id => $term_polygon) {
          if (is_array($term_polygon)) {
            $check = $pointLocation->pointInPolygon($point, $term_polygon);
            if ($check == 'inside') {
              $entity->field_city_region__torcond[LANGUAGE_NONE][0]['tid'] = $term_id;
            }
          }
        }
      }
      break;
  }
}


/**
 * Create json with Toronto neighbourhoods coordinates.
 */
function _ctrader_map_prepare_neighbourhoods_json($condos_neighbourhood_names = array(), $points_array = array()) {
//  $regions_xml = simplexml_load_file(drupal_get_path('module', 'ctrader_map') . '/inc/neigh_2.xml');
//  $neighbourhoods = array();
//  foreach ($regions_xml as $item) {
//    if (in_array($item->name, $condos_neighbourhood_names)) {
////    if (TRUE) {
//      $is_polygon = TRUE;
//      $coordinates = array();
//      foreach ($item->json_polygon->element as $pair) {
//        $count_pair = count($pair);
//        if (!$count_pair) {
//          $point = explode(',', $pair);
//          $point = array_reverse($point);
//          $coordinates[] = $point;
//        }
//        // if multipolygon
//        else {
//          $is_polygon = FALSE;
//          $pre_coordinates = array();
//          foreach ((array) $pair->element as $value) {
//            $point = explode(',', $value);
//            $point = array_reverse($point);
//            $pre_coordinates[] = $point;
//          }
//          $coordinates[] = $pre_coordinates;
//        }
//      }
//      $polygon_popup_content = !empty($item->name) ? $item->name->__toString() : 'Neighbourhood';
//      $prepared = array(
//        'id' => $item->id->__toString(),
//        'type' => 'Feature',
//        'properties' => array(
//          'name' => !empty($item->name) ? $item->name->__toString() : 'Neighbourhood',
//          'popupContent' => $polygon_popup_content,
//        ),
//        'geometry' => array(
//          'type' => $is_polygon ? 'Polygon' : 'MultiPolygon',
//          'coordinates' => array(
//            $coordinates,
//          ),
//        ),
//      );
//      $neighbourhoods[] = $prepared;
//    }
//
//  drupal_add_js(array('neighbourhoodsMapData' => $neighbourhoods), 'setting');


  if (!isset($_SESSION['neighbourhood_json'])) {
    $vid = taxonomy_vocabulary_machine_name_load('neighbourhoods'); //Neighbourhoods vocabulary.
    $vid = $vid->vid;
    $vocabulary_term_entities = taxonomy_get_tree($vid, 0, 3, TRUE);
    $terms_polygon_prejson = array();
    foreach ($vocabulary_term_entities as $tax_term) {
      $polygon = isset($tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom']) ? $tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom'] : NULL;
      if ($polygon !== NULL && $polygon != 'GEOMETRYCOLLECTION EMPTY') {
        $tax_term_id = $tax_term->tid;
        $tax_term_name = $tax_term->name;
        $polygon_popup_content = $tax_term_name;
        $coordinates = array();
        if (strrpos($tax_term->field_community_geolocation[LANGUAGE_NONE][0]['geom'], 'MULTIPOLYGON') === FALSE) {
          $type = 'Polygon';
          $polygon = str_replace(array('POLYGON ', '(', ')'), '', $polygon);
          $polygon = explode(', ', $polygon);
          $pre_coordinates = array();
          foreach ($polygon as $value) {
            $pre_coordinates[] = explode(' ', $value);
          }
          $coordinates[] = $pre_coordinates;
        }
        else {
          $type = 'MultiPolygon';
          $pre_coordinates = array();
          $polygon = str_replace(array(
            'MULTIPOLYGON ',
            '(((',
            ')))'
          ), '', $polygon);
          $pre_multi = explode('), (', $polygon);
          $pre_multi_coordinates = array();
          foreach ($pre_multi as $value) {
            $pre_points = explode(',', $value);
            $points = array();
            foreach ($pre_points as $pre_point) {
              $pre_point = trim($pre_point);
              $points[] = explode(' ', $pre_point);
            }
            $pre_multi_coordinates[] = $points;
          }
          $coordinates[] = $pre_multi_coordinates;
        }
        $terms_polygon_prejson[] = array(
          'geometry' => array(
            'coordinates' => $coordinates,
            'type' => $type,
          ),
          'properties' => array(
            'name' => $tax_term_name,
            'popupContent' => $polygon_popup_content,
          ),
          'id' => $tax_term_id,
          'type' => 'Feature',
        );
      }
    }
    $_SESSION['neighbourhood_json'] = $terms_polygon_prejson;
  }
  drupal_add_js(array('neighbourhoodsMapData' => $_SESSION['neighbourhood_json']), 'setting');

  return $_SESSION['neighbourhood_json'];
}

function _ctrader_map_kml_to_xml() {
  $xml = simplexml_load_file(drupal_get_path('module', 'ctrader_map') . '/inc/toronto_neighbourhoods.kml');
  $communities_array = array();
  $converted_kml_to_xml_string = '';
  foreach ($xml->Document->Folder->Placemark as $item) {
    $communities_array[] = (array) $item;
  }
  foreach ($communities_array as $item) {
    $coord_array = explode(';', $item['Polygon']->outerBoundaryIs->LinearRing->coordinates);
    $coord_xml = '<json_polygon>';
    foreach ($coord_array as $value) {
      $coord_pair = explode(',', $value);
      $coord_pair_string = '<element>' . trim($coord_pair[1]) . ',' . trim($coord_pair[0]) . '</element>';
      $coord_xml .= $coord_pair_string;
    }
    $coord_xml .= '</json_polygon>';
    $xml_string_item = '<element>' . $coord_xml . '<name>' . $item['name'] . '</name></element>';
    $converted_kml_to_xml_string .= $xml_string_item;
  }
  return $converted_kml_to_xml_string;
}


function _ctrader_map_region_taxonomy_form($form, &$form_state) {
  $form = array();
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Start terms creating'),
//    '#disabled' => TRUE,
  );
  return $form;
}


function _ctrader_map_region_taxonomy_form_submit($form, &$form_state) {
  _ctrader_map_taxonomy_create();
}

/**
 * Creates taxonomy term for each Toronto region.
 */
function _ctrader_map_taxonomy_create() {
  $vid = taxonomy_vocabulary_machine_name_load('neighbourhoods'); //Neighbourhoods vocabulary.
  $vid = $vid->vid;

  $select_list_condos_ca = array(
    '1' => array(
      'Toronto' => array(
        '590' => 'Downtown',
        '597' => 'Midtown',
        '593' => 'North York',
        '596' => 'East End',
        '598' => 'East York',
        '595' => 'West End',
        '594' => 'York Crosstown',
        '592' => 'Etobicoke',
        '591' => 'Scarborough',
      )
    ),
    '2' => array(
      'Peel' => array(
        '43' => 'Brampton',
        '44' => 'Mississauga',
      )
    ),
    '4' => array(
      'York Region' => array(
        '54' => 'Aurora',
        '49' => 'King',
        '51' => 'Markham',
        '55' => 'Newmarket',
        '52' => 'Richmond Hill',
        '50' => 'Vaughan',
      )
    ),
    '3' => array(
      'Halton' => array(
        '45' => 'Milton',
        '46' => 'Burlington',
        '47' => 'Halton Hills',
        '48' => 'Oakville',
      )
    ),
    '0' => array(
      'grandparent_0' => array(
        '599' => 'Hamilton',
      ),
    ),
    '5' => array(
      'grandparent_5' => array(
        '59' => 'parent_59',
        '60' => 'parent_60',
        '61' => 'parent_61',
        '62' => 'parent_62',
        '63' => 'parent_63',
        '64' => 'parent_64',
        '65' => 'parent_65',
        '66' => 'parent_66',
        '67' => 'parent_67',
      ),
    ),
  );

  // Creates main items for vocabulary.
  foreach ($select_list_condos_ca as $grand_id => $grand_parent) {
    $grand_pa_name = array_keys($grand_parent);
    $grand_pa_name = array_shift($grand_pa_name);
    $grand_pa = new stdClass();
    $grand_pa->name = $grand_pa_name;
    $grand_pa->vid = $vid;
    $grand_pa->field_id[LANGUAGE_NONE][0]['value'] = $grand_id;
    taxonomy_term_save($grand_pa);
    $grand_parent_just_created = taxonomy_get_term_by_name($grand_pa_name);
    $grand_parent_just_created = reset($grand_parent_just_created);
    $grand_parent_id = $grand_parent_just_created->tid;
    foreach ($grand_parent[$grand_pa_name] as $child_term_id => $child_term_name) {
      $child_term = new stdClass();
      $child_term->name = $child_term_name;
      $child_term->vid = $vid;
      $child_term->field_id[LANGUAGE_NONE][0]['value'] = $child_term_id;
      $child_term->parent = array($grand_parent_id => $grand_parent_id);
      taxonomy_term_save($child_term);
    }
  }

  $xml = simplexml_load_file(drupal_get_path('module', 'ctrader_map') . '/inc/condos-ca.xml');
  $vocabulary_main_terms = taxonomy_get_tree($vid, 0, 2, TRUE);
  foreach ($xml as $element) {
    $term_name = $element->name->__toString();
    $term_field_id_value = $element->id->__toString();
    $xml_parent_id = $element->parent_id->__toString();

    //Creates json for geofield.
    $is_polygon = TRUE;
    $coordinates = array();
    foreach ($element->json_polygon->element as $pair) {
      $count_pair = count($pair);
      if (!$count_pair) {
        $point = explode(',', $pair);
        $point = array_reverse($point);
        $coordinates[] = $point;
      }
      // if multipolygon
      else {
        $is_polygon = FALSE;
        $pre_coordinates = array();
        foreach ((array) $pair->element as $value) {
          $point = explode(',', $value);
          $point = array_reverse($point);
          $pre_coordinates[] = $point;
        }
        $coordinates[] = $pre_coordinates;
      }
    }
    if ($is_polygon == TRUE && implode('_', $coordinates[0]) != implode('_', end($coordinates))) {
      $coordinates[] = $coordinates[0];
    }
    $prepared = array(
      'id' => $element->id->__toString(),
      'type' => 'Feature',
      'properties' => array(
        'name' => !empty($element->name) ? $element->name->__toString() : 'Neighbourhood',
      ),
      'geometry' => array(
        'type' => $is_polygon ? 'Polygon' : 'MultiPolygon',
        'coordinates' => array(
          $coordinates,
        ),
      ),
    );
    $polygon_json = json_encode($prepared);

    // Finds which one of existed terms would be parent
    // and create new parent term if not exist.
    $parent_id = -1;
    foreach ($vocabulary_main_terms as $parent_terms) {
      if ($xml_parent_id == $parent_terms->field_id[LANGUAGE_NONE][0]['value']) {
        $parent_id = $parent_terms->tid;
      }
    }
    if ($parent_id == -1) {
      $parent_term = new stdClass();
      $parent_term->name = 'parent_' . $element->parent_id->__toString();
      $parent_term->vid = $vid;
      $parent_term->field_id[LANGUAGE_NONE][0]['value'] = $element->parent_id->__toString();
      $parent_term->parent = array($element->grandparent_id->__toString() => $element->grandparent_id->__toString());
      taxonomy_term_save($parent_term);
      $parent_just_created = taxonomy_get_term_by_name('parent_' . $element->parent_id->__toString());
      $parent_just_created = reset($parent_just_created);
      $parent_id = $parent_just_created->tid;
      $vocabulary_main_terms = taxonomy_get_tree($vid, 0, 2, TRUE);
    }

    $term = new stdClass();
    $term->name = $term_name;
    $term->vid = $vid;
    $term->field_community_geolocation[LANGUAGE_NONE][0]['geom'] = $polygon_json;
    $term->field_community_geolocation[LANGUAGE_NONE][0]['input_format'] = 'json';
    $term->field_id[LANGUAGE_NONE][0]['value'] = $term_field_id_value;
    $term->parent = array($parent_id => $parent_id);
    taxonomy_term_save($term);
  }
}
